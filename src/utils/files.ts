import fs from 'fs';
import path from 'path';
import os from 'os';
import crypto from 'crypto';

export interface ScanResult {
  [relativePath: string]: Buffer;
}

export function scanDir(dir: string, base = ''): ScanResult {
  const result: ScanResult = {};
  if (!fs.existsSync(dir)) return result;

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relPath = base ? path.join(base, entry.name) : entry.name;

    if (entry.isDirectory()) {
      Object.assign(result, scanDir(fullPath, relPath));
    } else {
      result[relPath] = fs.readFileSync(fullPath);
    }
  }
  return result;
}

export interface DiffResult {
  added: string[];
  modified: string[];
  removed: string[];
  unchanged: string[];
}

export function compareConfigs(source: ScanResult, installed: ScanResult): DiffResult {
  const added: string[] = [];
  const modified: string[] = [];
  const removed: string[] = [];
  const unchanged: string[] = [];

  for (const [rel, buf] of Object.entries(source)) {
    if (!(rel in installed)) {
      added.push(rel);
    } else if (!buf.equals(installed[rel])) {
      modified.push(rel);
    } else {
      unchanged.push(rel);
    }
  }

  for (const rel of Object.keys(installed)) {
    if (!(rel in source)) {
      removed.push(rel);
    }
  }

  return { added, modified, removed, unchanged };
}

export function computeFileHashes(dir: string, base = ''): Record<string, string> {
  const hashes: Record<string, string> = {};
  if (!fs.existsSync(dir)) return hashes;

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relPath = base ? path.join(base, entry.name) : entry.name;

    if (entry.isDirectory()) {
      Object.assign(hashes, computeFileHashes(fullPath, relPath));
    } else {
      const content = fs.readFileSync(fullPath);
      hashes[relPath] = crypto.createHash('md5').update(content).digest('hex');
    }
  }
  return hashes;
}

export function getTargetDir(scope: 'project' | 'global'): string {
  return scope === 'global' ? os.homedir() : process.cwd();
}

export function getConfigPath(scope: 'project' | 'global'): string {
  const base = getTargetDir(scope);
  return path.join(base, '.ai-nexus');
}

export function ensureDir(dir: string): void {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

export function copyFile(src: string, dest: string): void {
  ensureDir(path.dirname(dest));
  fs.copyFileSync(src, dest);
}

const AGENTS_CATEGORIES = ['rules', 'commands', 'skills', 'agents', 'contexts'];
const CATEGORY_LABELS: Record<string, string> = {
  rules: 'Rules',
  commands: 'Commands',
  skills: 'Skills',
  agents: 'Agents',
  contexts: 'Contexts',
};

function stripFrontmatter(content: string): string {
  return content.replace(/^---\r?\n[\s\S]*?\r?\n---\r?\n*/, '').trim();
}

/**
 * Aggregate rule files into a single AGENTS.md content string.
 * If selectedFiles is provided, only those files are included.
 * Otherwise, all .md files in each category directory are included.
 */
export function aggregateToAgentsMd(configDir: string, selectedFiles?: Record<string, string[]>): string {
  const sections: string[] = [];

  sections.push('# AI Agent Guidelines\n');
  sections.push('> Auto-generated by ai-nexus. Do not edit manually.\n');

  for (const category of AGENTS_CATEGORIES) {
    const catDir = path.join(configDir, category);
    if (!fs.existsSync(catDir)) continue;

    let files: string[];
    if (selectedFiles && selectedFiles[category]) {
      files = selectedFiles[category];
    } else {
      // Scan all .md files in the category directory
      files = fs.readdirSync(catDir).filter(f => f.endsWith('.md'));
    }

    if (files.length === 0) continue;

    const label = CATEGORY_LABELS[category] || category;
    sections.push(`## ${label}\n`);

    for (const file of files) {
      const filePath = path.join(catDir, file);
      if (!fs.existsSync(filePath)) continue;

      const raw = fs.readFileSync(filePath, 'utf8');
      const body = stripFrontmatter(raw);
      if (!body) continue;

      sections.push(body);
      sections.push('');
    }
  }

  return sections.join('\n').trim() + '\n';
}

export function detectInstall(): { configPath: string; scope: 'project' | 'global' } | null {
  const projectPath = path.join(process.cwd(), '.ai-nexus');
  if (fs.existsSync(projectPath)) {
    return { configPath: projectPath, scope: 'project' };
  }

  const globalPath = path.join(os.homedir(), '.ai-nexus');
  if (fs.existsSync(globalPath)) {
    return { configPath: globalPath, scope: 'global' };
  }

  return null;
}
